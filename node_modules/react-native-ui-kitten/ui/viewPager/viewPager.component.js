/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from 'react';
import { Animated, Easing, PanResponder, StyleSheet, View, } from 'react-native';
import { I18nLayoutService } from '../support/services';
/**
 * `ViewPager` allows flipping through the "pages".
 *
 * @extends React.Component
 *
 * @property {React.ReactElement<any> | React.ReactElement<any>[]} children - Determines children of the component.
 *
 * @property {number} selectedIndex - Determines the index of selected "page".
 *
 * @property {(index: number) => boolean} shouldLoadComponent - Determines loading behavior particular page and can be
 * used for lazy loading.
 *
 * @property {(offset: number) => void} onOffsetChange - Fires on scroll event with current scroll offset.
 *
 * @property {(index: number) => void} onSelect - Fires on "page" select with corresponding index.
 *
 * @property ScrollViewProps
 *
 * @overview-example Simple Usage
 *
 * ```
 * import React from 'react';
 * import { ViewPager, Layout, Text } from '../..';
 *
 * export class ViewPagerShowcase extends React.Component {
 *
 *   state = {
 *      selectedIndex: 0,
 *    };
 *
 *   onIndexChange = (selectedIndex) => {
 *     this.setState({ selectedIndex });
 *   };
 *
 *   render() {
 *     return (
 *       <ViewPager
 *         selectedIndex={this.state.selectedIndex}
 *         onSelect={this.onIndexChange}>
 *         <Layout>
 *           <Text>Tab 1</Text>
 *         </Layout>
 *         <Layout>
 *           <Text>Tab 2</Text>
 *         </Layout>
 *       </ViewPager>
 *     );
 *   }
 * }
 * ```
 *
 * @overview-example Lazy Loading
 *
 * ```
 * import React from 'react';
 * import { ViewPager, Layout, Text } from '../..';
 *
 * export class ViewPagerShowcase extends React.Component {
 *
 *   state = {
 *     selectedIndex: 0,
 *   };
 *
 *   onIndexChange = (selectedIndex) => {
 *     this.setState({ selectedIndex });
 *   };
 *
 *   shouldLoadPageContent = (index) => {
 *     return index === this.state.selectedIndex;
 *   };
 *
 *   render() {
 *     return (
 *       <ViewPager
 *         selectedIndex={this.state.selectedIndex}
 *         shouldLoadComponent={this.shouldLoadPageContent}
 *         onSelect={this.onIndexChange}>
 *         <Layout>
 *           <Text>Tab 1</Text>
 *         </Layout>
 *         <Layout>
 *           <Text>Tab 2</Text>
 *         </Layout>
 *       </ViewPager>
 *     );
 *   }
 * }
 * ```
 *
 * @example Inline Styling
 *
 * ```
 * import React from 'react';
 * import { StyleSheet } from 'react-native';
 * import { ViewPager, Layout, Text } from '../..';
 *
 * export class ViewPagerShowcase extends React.Component {
 *
 *   state = {
 *      selectedIndex: 0,
 *    };
 *
 *   onIndexChange = (selectedIndex) => {
 *     this.setState({ selectedIndex });
 *   };
 *
 *   render() {
 *     return (
 *       <ViewPager
 *         style={styles.container}
 *         selectedIndex={this.state.selectedIndex}
 *         onSelect={this.onIndexChange}>
 *         <Layout>
 *           <Text>Tab 1</Text>
 *         </Layout>
 *         <Layout>
 *           <Text>Tab 2</Text>
 *         </Layout>
 *       </ViewPager>
 *     );
 *   }
 * }
 *
 * const styles = StyleSheet.create({
 *   container: { paddingHorizontal: 16 },
 * });
 * ```
 */
export class ViewPager extends React.Component {
    constructor() {
        super(...arguments);
        this.containerRef = React.createRef();
        this.contentWidth = 0;
        this.contentOffsetValue = 0;
        this.contentOffset = new Animated.Value(this.contentOffsetValue);
        this.panResponder = PanResponder.create(this);
        this.onMoveShouldSetPanResponder = (event, state) => {
            const isHorizontalMove = Math.abs(state.dx) > 0 && Math.abs(state.dx) > Math.abs(state.dy);
            if (isHorizontalMove) {
                const i18nOffset = I18nLayoutService.select(state.dx, -state.dx);
                const nextSelectedIndex = this.props.selectedIndex - Math.sign(i18nOffset);
                return nextSelectedIndex >= 0 && nextSelectedIndex < this.getChildCount();
            }
            return false;
        };
        this.onPanResponderMove = (event, state) => {
            const i18nOffset = I18nLayoutService.select(this.contentWidth, -this.contentWidth);
            const selectedPageOffset = this.props.selectedIndex * i18nOffset;
            this.contentOffset.setValue(state.dx - selectedPageOffset);
        };
        this.onPanResponderRelease = (event, state) => {
            if (Math.abs(state.vx) >= 0.5 || Math.abs(state.dx) >= 0.5 * this.contentWidth) {
                const i18nOffset = I18nLayoutService.select(state.dx, -state.dx);
                const index = i18nOffset > 0 ? this.props.selectedIndex - 1 : this.props.selectedIndex + 1;
                this.scrollToIndex({ index, animated: true });
            }
            else {
                const index = this.props.selectedIndex;
                this.scrollToIndex({ index, animated: true });
            }
        };
        this.scrollToOffset = (params) => {
            this.createOffsetAnimation(params).start(this.onContentOffsetAnimationStateEnd);
        };
        this.onLayout = (event) => {
            this.contentWidth = event.nativeEvent.layout.width / this.getChildCount();
            this.scrollToIndex({
                index: this.props.selectedIndex,
            });
        };
        this.onContentOffsetAnimationStateChanged = (state) => {
            this.contentOffsetValue = I18nLayoutService.select(-state.value, state.value);
            if (this.props.onOffsetChange) {
                this.props.onOffsetChange(this.contentOffsetValue);
            }
        };
        this.onContentOffsetAnimationStateEnd = (result) => {
            const selectedIndex = this.contentOffsetValue / this.contentWidth;
            if (selectedIndex !== this.props.selectedIndex && this.props.onSelect) {
                this.props.onSelect(Math.round(selectedIndex));
            }
        };
        this.createOffsetAnimation = (params) => {
            const animationDuration = params.animated ? 300 : 0;
            return Animated.timing(this.contentOffset, {
                toValue: I18nLayoutService.select(-params.offset, params.offset),
                easing: Easing.linear,
                duration: animationDuration,
            });
        };
        this.renderComponentChild = (source, index) => {
            const contentView = this.props.shouldLoadComponent(index) ? source : null;
            return (<View style={styles.contentContainer}>
        {contentView}
      </View>);
        };
        this.renderComponentChildren = (source) => {
            return React.Children.map(source, this.renderComponentChild);
        };
        this.getChildCount = () => {
            return React.Children.count(this.props.children);
        };
        this.getContainerStyle = () => {
            return {
                width: `${100 * this.getChildCount()}%`,
                // @ts-ignore: RN has no types for `Animated` styles
                transform: [{ translateX: this.contentOffset }],
            };
        };
    }
    componentDidMount() {
        this.contentOffset.addListener(this.onContentOffsetAnimationStateChanged);
    }
    componentDidUpdate(prevProps) {
        if (prevProps.selectedIndex !== this.props.selectedIndex) {
            const index = this.props.selectedIndex;
            this.scrollToIndex({ index, animated: true });
        }
    }
    componentWillUnmount() {
        this.contentOffset.removeAllListeners();
    }
    scrollToIndex(params) {
        const { index } = params, rest = __rest(params, ["index"]);
        const childCount = this.getChildCount() - 1;
        const offset = this.contentWidth * (index < 0 ? 0 : index > childCount ? childCount : index);
        this.scrollToOffset(Object.assign({ offset }, rest));
    }
    render() {
        const _a = this.props, { style, children } = _a, restProps = __rest(_a, ["style", "children"]);
        return (<Animated.View {...restProps} ref={this.containerRef} style={[styles.container, style, this.getContainerStyle()]} onLayout={this.onLayout} {...this.panResponder.panHandlers}>
        {this.renderComponentChildren(children)}
      </Animated.View>);
    }
}
ViewPager.defaultProps = {
    selectedIndex: 0,
    shouldLoadComponent: () => true,
};
const styles = StyleSheet.create({
    container: {
        flexDirection: 'row',
    },
    contentContainer: {
        flex: 1,
        width: '100%',
    },
});
//# sourceMappingURL=viewPager.component.js.map