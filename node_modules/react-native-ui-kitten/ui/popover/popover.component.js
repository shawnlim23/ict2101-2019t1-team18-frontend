/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from 'react';
import { Dimensions, StyleSheet, View, } from 'react-native';
import { ModalService, styled, } from '../../theme';
import { PopoverView, } from './popoverView.component';
import { MeasureNode, } from './measure.component';
import { Frame, Offsets, PopoverPlacements, } from './type';
import { PopoverPlacementService } from './placement.service';
const WINDOW = Dimensions.get('window');
const WINDOW_BOUNDS = new Frame(0, 0, WINDOW.width, WINDOW.height);
const TAG_CHILD = 0;
const TAG_CONTENT = 1;
const PLACEMENT_DEFAULT = PopoverPlacements.BOTTOM;
/**
 * Displays content in a `Modal` when users focus on or tap an element. Also supports automatic placement.
 *
 * @extends React.Component
 *
 * @property {React.ReactElement<any>} content - Determines the content of the popover.
 *
 * @property {React.ReactElement<any>} children - Determines the element "above" which popover will be shown.
 *
 * @property {boolean} visible - Determines whether popover is visible or not.
 *
 * @property {string | PopoverPlacement} placement - Determines the placement of the popover.
 * Can be `left`, `top`, `right`, `bottom`, `left start`, `left end`, `top start`, `top end`, `right start`,
 * `right end`, `bottom start` or `bottom end`.
 * Default is `bottom`.
 *
 * @property {number} indicatorOffset - Determines the offset of indicator (arrow).
 * @property {StyleProp<ViewStyle>} indicatorStyle - Determines style of indicator (arrow).
 *
 * @property ViewProps
 *
 * @property ModalPresentingBased
 *
 * @property StyledComponentProps
 *
 * @overview-example Simple Usage
 *
 * ```
 * import React from 'react';
 * import { StyleSheet } from 'react-native';
 * import { Popover, Layout, Button, Text } from '../..';
 *
 * export class PopoverShowcase extends React.Component {
 *
 *   state = {
 *     popoverVisible: false,
 *   };
 *
 *   togglePopover = () => {
 *     const popoverVisible = !this.state.popoverVisible;
 *     this.setState({ popoverVisible });
 *   };
 *
 *   renderPopoverContentElement = () => (
 *     <Layout style={styles.popoverContent}>
 *       <Text>Hi! This is popover.</Text>
 *     </Layout>
 *   );
 *
 *   render() {
 *     return (
 *       <Popover
 *         visible={this.state.popoverVisible}
 *         content={this.renderPopoverContentElement()}
 *         onBackdropPress={this.togglePopover}>
 *         <Button onPress={this.togglePopover}>TOGGLE POPOVER</Button>
 *       </Popover>
 *     );
 *   }
 * }
 *
 * const styles = StyleSheet.create({
 *   popoverContent: { justifyContent: 'center', alignItems: 'center' },
 * });
 * ```
 */
export class PopoverComponent extends React.Component {
    constructor() {
        super(...arguments);
        this.placementService = new PopoverPlacementService();
        this.handleVisibility = (prevProps) => {
            if (prevProps.visible !== this.props.visible) {
                if (this.props.visible) {
                    // Toggles re-measuring. This is needed for dynamic containers like ScrollView
                    this.setState({ layout: undefined });
                }
                else {
                    this.popoverId = ModalService.hide(this.popoverId);
                }
            }
            else if (prevProps.visible && this.props.visible) {
                this.updatePopoverElement();
            }
        };
        this.updatePopoverElement = () => {
            const element = this.renderPopoverElement(this.props.content, this.popoverPlacement);
            const popoverElement = React.cloneElement(element, {
                style: [element.props.style, styles.popoverVisible],
            });
            this.popoverId && ModalService.update(this.popoverId, popoverElement);
        };
        this.getComponentStyle = (source) => {
            const { indicatorWidth, indicatorHeight, indicatorBackgroundColor } = source, containerParameters = __rest(source, ["indicatorWidth", "indicatorHeight", "indicatorBackgroundColor"]);
            return {
                container: containerParameters,
                indicator: {
                    width: indicatorWidth,
                    height: indicatorHeight,
                    backgroundColor: indicatorBackgroundColor,
                },
            };
        };
        this.onMeasure = (layout) => {
            if (this.props.visible) {
                const placementOptions = this.createPlacementOptions(layout);
                const popoverPlacement = this.placementService.find(this.popoverPlacement, placementOptions);
                this.popoverId = this.showPopoverModal(popoverPlacement, placementOptions);
            }
        };
        this.createPlacement = (value) => {
            return PopoverPlacements.parse(value, PLACEMENT_DEFAULT);
        };
        this.createPlacementOptions = (layout) => {
            const { children } = this.props;
            return {
                source: layout[TAG_CONTENT],
                other: layout[TAG_CHILD],
                bounds: WINDOW_BOUNDS,
                offsets: Offsets.find(children.props.style),
            };
        };
        this.showPopoverModal = (placement, options) => {
            const popoverFrame = placement.frame(options);
            const popoverElement = this.renderPopoverElement(this.props.content, placement);
            const positionStyle = {
                left: popoverFrame.origin.x,
                top: popoverFrame.origin.y,
            };
            const positionedPopoverElement = React.cloneElement(popoverElement, {
                style: [styles.popoverVisible, positionStyle],
            });
            return ModalService.show(positionedPopoverElement, {
                allowBackdrop: this.props.allowBackdrop,
                onBackdropPress: this.props.onBackdropPress,
            });
        };
        this.renderPopoverElement = (children, placement) => {
            const _a = this.props, { style: derivedStyle, themedStyle, indicatorStyle } = _a, derivedProps = __rest(_a, ["style", "themedStyle", "indicatorStyle"]);
            const { container, indicator } = this.getComponentStyle(themedStyle);
            const measuringProps = { tag: TAG_CONTENT };
            return (<View {...measuringProps} key={TAG_CONTENT} style={[styles.popover, styles.popoverInvisible]}>
        <PopoverView {...derivedProps} style={[container, derivedStyle]} indicatorStyle={[indicator, styles.indicator, indicatorStyle]} placement={placement.reverse().rawValue}>
          {children}
        </PopoverView>
      </View>);
        };
        this.renderChildElement = (source) => {
            const measuringProps = { tag: TAG_CHILD };
            return (<View {...measuringProps} key={TAG_CHILD} style={styles.child}>
        {source}
      </View>);
        };
        this.renderMeasuringElement = (...children) => {
            return (<MeasureNode onResult={this.onMeasure}>
        {children}
      </MeasureNode>);
        };
    }
    componentDidUpdate(prevProps) {
        this.handleVisibility(prevProps);
    }
    render() {
        if (this.props.visible) {
            this.popoverPlacement = this.createPlacement(this.props.placement);
            const popoverElement = this.renderPopoverElement(this.props.content, this.popoverPlacement);
            const childElement = this.renderChildElement(this.props.children);
            return this.renderMeasuringElement(childElement, popoverElement);
        }
        return this.props.children;
    }
}
PopoverComponent.styledComponentName = 'Popover';
PopoverComponent.defaultProps = {
    placement: PLACEMENT_DEFAULT.rawValue,
    visible: false,
    allowBackdrop: true,
    onBackdropPress: () => null,
};
const styles = StyleSheet.create({
    popover: {
        position: 'absolute',
    },
    popoverInvisible: {
        opacity: 0,
    },
    popoverVisible: {
        opacity: 1,
    },
    indicator: {},
    child: {},
});
export const Popover = styled(PopoverComponent);
//# sourceMappingURL=popover.component.js.map