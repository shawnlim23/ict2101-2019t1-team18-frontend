/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import { StyleSheet, } from 'react-native';
import { I18nLayoutService } from '../support/services';
export class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    static zero() {
        return new Point(0, 0);
    }
}
export class Size {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
    static zero() {
        return new Size(0, 0);
    }
}
export class Frame {
    constructor(x, y, width, height) {
        this.origin = new Point(x, y);
        this.size = new Size(width, height);
    }
    /**
     * Creates new frame aligned to left of other
     */
    leftOf(other) {
        return new Frame(other.origin.x - this.size.width, this.origin.y, this.size.width, this.size.height);
    }
    /**
     * Creates new frame aligned to top of other
     */
    topOf(other) {
        return new Frame(this.origin.x, other.origin.y - this.size.height, this.size.width, this.size.height);
    }
    /**
     * Creates new frame aligned to right of other
     */
    rightOf(other) {
        return new Frame(other.origin.x + other.size.width, this.origin.y, this.size.width, this.size.height);
    }
    /**
     * Creates new frame aligned to bottom of other
     */
    bottomOf(other) {
        return new Frame(this.origin.x, other.origin.y + other.size.height, this.size.width, this.size.height);
    }
    /**
     * Creates new frame centered horizontally to other
     */
    centerHorizontalOf(other) {
        return new Frame(other.origin.x + (other.size.width - this.size.width) / 2, this.origin.y, this.size.width, this.size.height);
    }
    /**
     * Creates new frame centered vertically to other
     */
    centerVerticalOf(other) {
        return new Frame(this.origin.x, other.origin.y + (other.size.height - this.size.height) / 2, this.size.width, this.size.height);
    }
    static zero() {
        return Frame.from(Point.zero(), Size.zero());
    }
    static from(point, size) {
        return new Frame(point.x, point.y, size.width, size.height);
    }
}
export class OffsetRect {
    static zero() {
        return { left: 0, top: 0, right: 0, bottom: 0 };
    }
}
export class Offsets {
    static find(source) {
        const keys = [
            Offsets.MARGIN.rawValue,
            Offsets.MARGIN_HORIZONTAL.rawValue,
            Offsets.MARGIN_VERTICAL.rawValue,
            Offsets.MARGIN_LEFT.rawValue,
            Offsets.MARGIN_TOP.rawValue,
            Offsets.MARGIN_RIGHT.rawValue,
            Offsets.MARGIN_BOTTOM.rawValue,
        ];
        const flatStyle = StyleSheet.flatten(source) || {};
        return Object.keys(flatStyle).filter((key) => {
            return keys.includes(key);
        }).reduce((acc, key) => {
            const value = flatStyle[key];
            const offsetValue = Offsets.parseString(key);
            return offsetValue ? offsetValue.applyToRect(acc, value) : acc;
        }, OffsetRect.zero());
    }
    static parseString(rawValue, fallback) {
        switch (rawValue) {
            case Offsets.MARGIN.rawValue:
                return Offsets.MARGIN;
            case Offsets.MARGIN_HORIZONTAL.rawValue:
                return Offsets.MARGIN_HORIZONTAL;
            case Offsets.MARGIN_VERTICAL.rawValue:
                return Offsets.MARGIN_VERTICAL;
            case Offsets.MARGIN_LEFT.rawValue:
                return Offsets.MARGIN_LEFT;
            case Offsets.MARGIN_TOP.rawValue:
                return Offsets.MARGIN_TOP;
            case Offsets.MARGIN_RIGHT.rawValue:
                return Offsets.MARGIN_RIGHT;
            case Offsets.MARGIN_BOTTOM.rawValue:
                return Offsets.MARGIN_BOTTOM;
            default:
                return fallback;
        }
    }
}
Offsets.MARGIN = new class {
    constructor() {
        this.rawValue = 'margin';
    }
    applyToRect(rect, value) {
        return {
            left: value,
            top: value,
            right: value,
            bottom: value,
        };
    }
};
Offsets.MARGIN_HORIZONTAL = new class {
    constructor() {
        this.rawValue = 'marginHorizontal';
    }
    applyToRect(rect, value) {
        return Object.assign(Object.assign({}, rect), { left: value, right: value });
    }
};
Offsets.MARGIN_VERTICAL = new class {
    constructor() {
        this.rawValue = 'marginVertical';
    }
    applyToRect(rect, value) {
        return Object.assign(Object.assign({}, rect), { top: value, bottom: value });
    }
};
Offsets.MARGIN_LEFT = new class {
    constructor() {
        this.rawValue = 'marginLeft';
    }
    applyToRect(rect, value) {
        return Object.assign(Object.assign({}, rect), { left: value });
    }
};
Offsets.MARGIN_TOP = new class {
    constructor() {
        this.rawValue = 'marginTop';
    }
    applyToRect(rect, value) {
        return Object.assign(Object.assign({}, rect), { top: value });
    }
};
Offsets.MARGIN_RIGHT = new class {
    constructor() {
        this.rawValue = 'marginRight';
    }
    applyToRect(rect, value) {
        return Object.assign(Object.assign({}, rect), { right: value });
    }
};
Offsets.MARGIN_BOTTOM = new class {
    constructor() {
        this.rawValue = 'marginBottom';
    }
    applyToRect(rect, value) {
        return Object.assign(Object.assign({}, rect), { bottom: value });
    }
};
export class PlacementOptions {
    constructor() {
        this.source = Frame.zero();
        this.other = Frame.zero();
        this.bounds = Frame.zero();
        this.offsets = OffsetRect.zero();
    }
}
export class PopoverPlacements {
    static parse(value, fallback) {
        return PopoverPlacements.typeOf(value) ? value : PopoverPlacements.parseString(value, fallback);
    }
    static parseString(rawValue, fallback) {
        switch (rawValue) {
            case PopoverPlacements.LEFT.rawValue:
                return PopoverPlacements.LEFT;
            case PopoverPlacements.TOP.rawValue:
                return PopoverPlacements.TOP;
            case PopoverPlacements.RIGHT.rawValue:
                return PopoverPlacements.RIGHT;
            case PopoverPlacements.BOTTOM.rawValue:
                return PopoverPlacements.BOTTOM;
            case PopoverPlacements.LEFT_START.rawValue:
                return PopoverPlacements.LEFT_START;
            case PopoverPlacements.LEFT_END.rawValue:
                return PopoverPlacements.LEFT_END;
            case PopoverPlacements.TOP_START.rawValue:
                return PopoverPlacements.TOP_START;
            case PopoverPlacements.TOP_END.rawValue:
                return PopoverPlacements.TOP_END;
            case PopoverPlacements.RIGHT_START.rawValue:
                return PopoverPlacements.RIGHT_START;
            case PopoverPlacements.RIGHT_END.rawValue:
                return PopoverPlacements.RIGHT_END;
            case PopoverPlacements.BOTTOM_START.rawValue:
                return PopoverPlacements.BOTTOM_START;
            case PopoverPlacements.BOTTOM_END.rawValue:
                return PopoverPlacements.BOTTOM_END;
            default:
                return fallback;
        }
    }
    static typeOf(value) {
        const { rawValue } = value;
        return rawValue !== undefined;
    }
}
PopoverPlacements.LEFT = new class {
    constructor() {
        this.rawValue = 'left';
    }
    frame(options) {
        const { origin, size } = options.source.leftOf(options.other).centerVerticalOf(options.other);
        const x = I18nLayoutService.select(origin.x + options.offsets.left, options.bounds.size.width - size.width - (origin.x + options.offsets.right));
        return new Frame(x, origin.y, size.width, size.height);
    }
    flex() {
        return {
            direction: 'row',
            alignment: 'center',
        };
    }
    parent() {
        return this;
    }
    reverse() {
        return PopoverPlacements.RIGHT;
    }
    family() {
        return [
            PopoverPlacements.LEFT,
            PopoverPlacements.LEFT_START,
            PopoverPlacements.LEFT_END,
        ];
    }
    fits(frame, other) {
        return fitsStart(frame, other) && fitsTop(frame, other) && fitsBottom(frame, other);
    }
};
PopoverPlacements.LEFT_START = new class {
    constructor() {
        this.rawValue = 'left start';
    }
    frame(options) {
        const { origin, size } = this.parent().frame(options);
        return new Frame(origin.x, origin.y - (options.other.size.height - size.height) / 2 + options.offsets.top, size.width, size.height);
    }
    flex() {
        return {
            direction: 'row',
            alignment: 'flex-start',
        };
    }
    parent() {
        return PopoverPlacements.LEFT;
    }
    reverse() {
        return PopoverPlacements.RIGHT_START;
    }
    family() {
        return this.parent().family();
    }
    fits(frame, other) {
        return this.parent().fits(frame, other);
    }
};
PopoverPlacements.LEFT_END = new class {
    constructor() {
        this.rawValue = 'left end';
    }
    frame(options) {
        const { origin, size } = this.parent().frame(options);
        return new Frame(origin.x, origin.y + (options.other.size.height - size.height) / 2 - options.offsets.bottom, size.width, size.height);
    }
    flex() {
        return {
            direction: 'row',
            alignment: 'flex-end',
        };
    }
    parent() {
        return PopoverPlacements.LEFT;
    }
    reverse() {
        return PopoverPlacements.RIGHT_END;
    }
    family() {
        return this.parent().family();
    }
    fits(frame, other) {
        return this.parent().fits(frame, other);
    }
};
PopoverPlacements.TOP = new class {
    constructor() {
        this.rawValue = 'top';
    }
    frame(options) {
        const { origin, size } = options.source.topOf(options.other).centerHorizontalOf(options.other);
        const x = I18nLayoutService.select(origin.x, options.bounds.size.width - (origin.x + size.width));
        return new Frame(x, origin.y + options.offsets.top, size.width, size.height);
    }
    flex() {
        return {
            direction: 'column',
            alignment: 'center',
        };
    }
    parent() {
        return this;
    }
    reverse() {
        return PopoverPlacements.BOTTOM;
    }
    family() {
        return [
            PopoverPlacements.TOP,
            PopoverPlacements.TOP_START,
            PopoverPlacements.TOP_END,
        ];
    }
    fits(frame, other) {
        return fitsTop(frame, other) && fitsLeft(frame, other) && fitsRight(frame, other);
    }
};
PopoverPlacements.TOP_START = new class {
    constructor() {
        this.rawValue = 'top start';
    }
    frame(options) {
        const { origin, size } = this.parent().frame(options);
        return new Frame(origin.x - (options.other.size.width - size.width) / 2 + options.offsets.left, origin.y, size.width, size.height);
    }
    flex() {
        return {
            direction: 'column',
            alignment: 'flex-start',
        };
    }
    parent() {
        return PopoverPlacements.TOP;
    }
    reverse() {
        return PopoverPlacements.BOTTOM_START;
    }
    family() {
        return this.parent().family();
    }
    fits(frame, other) {
        return this.parent().fits(frame, other);
    }
};
PopoverPlacements.TOP_END = new class {
    constructor() {
        this.rawValue = 'top end';
    }
    frame(options) {
        const { origin, size } = this.parent().frame(options);
        return new Frame(origin.x + (options.other.size.width - size.width) / 2 - options.offsets.right, origin.y, size.width, size.height);
    }
    flex() {
        return {
            direction: 'column',
            alignment: 'flex-end',
        };
    }
    parent() {
        return PopoverPlacements.TOP;
    }
    reverse() {
        return PopoverPlacements.BOTTOM_END;
    }
    family() {
        return this.parent().family();
    }
    fits(frame, other) {
        return this.parent().fits(frame, other);
    }
};
PopoverPlacements.RIGHT = new class {
    constructor() {
        this.rawValue = 'right';
    }
    frame(options) {
        const { origin, size } = options.source.rightOf(options.other).centerVerticalOf(options.other);
        const x = I18nLayoutService.select(origin.x - options.offsets.right, options.bounds.size.width - size.width - (origin.x - options.offsets.right));
        return new Frame(x, origin.y, size.width, size.height);
    }
    flex() {
        return {
            direction: 'row-reverse',
            alignment: 'center',
        };
    }
    parent() {
        return this;
    }
    reverse() {
        return PopoverPlacements.LEFT;
    }
    family() {
        return [
            PopoverPlacements.RIGHT,
            PopoverPlacements.RIGHT_START,
            PopoverPlacements.RIGHT_END,
        ];
    }
    fits(frame, other) {
        return fitsEnd(frame, other) && fitsTop(frame, other) && fitsBottom(frame, other);
    }
};
PopoverPlacements.RIGHT_START = new class {
    constructor() {
        this.rawValue = 'right start';
    }
    frame(options) {
        const { origin, size } = this.parent().frame(options);
        return new Frame(origin.x, origin.y - (options.other.size.height - size.height) / 2 + options.offsets.top, size.width, size.height);
    }
    flex() {
        return {
            direction: 'row-reverse',
            alignment: 'flex-start',
        };
    }
    parent() {
        return PopoverPlacements.RIGHT;
    }
    reverse() {
        return PopoverPlacements.LEFT_START;
    }
    family() {
        return this.parent().family();
    }
    fits(frame, other) {
        return this.parent().fits(frame, other);
    }
};
PopoverPlacements.RIGHT_END = new class {
    constructor() {
        this.rawValue = 'right end';
    }
    frame(options) {
        const { origin, size } = this.parent().frame(options);
        return new Frame(origin.x, origin.y + (options.other.size.height - size.height) / 2 - options.offsets.bottom, size.width, size.height);
    }
    flex() {
        return {
            direction: 'row-reverse',
            alignment: 'flex-end',
        };
    }
    parent() {
        return PopoverPlacements.RIGHT;
    }
    reverse() {
        return PopoverPlacements.LEFT_END;
    }
    family() {
        return this.parent().family();
    }
    fits(frame, other) {
        return this.parent().fits(frame, other);
    }
};
PopoverPlacements.BOTTOM = new class {
    constructor() {
        this.rawValue = 'bottom';
    }
    frame(options) {
        const { origin, size } = options.source.bottomOf(options.other).centerHorizontalOf(options.other);
        const x = I18nLayoutService.select(origin.x, options.bounds.size.width - (origin.x + size.width));
        return new Frame(x, origin.y - options.offsets.bottom, size.width, size.height);
    }
    flex() {
        return {
            direction: 'column-reverse',
            alignment: 'center',
        };
    }
    parent() {
        return this;
    }
    reverse() {
        return PopoverPlacements.TOP;
    }
    family() {
        return [
            PopoverPlacements.BOTTOM,
            PopoverPlacements.BOTTOM_START,
            PopoverPlacements.BOTTOM_END,
        ];
    }
    fits(frame, other) {
        return fitsBottom(frame, other) && fitsLeft(frame, other) && fitsRight(frame, other);
    }
};
PopoverPlacements.BOTTOM_START = new class {
    constructor() {
        this.rawValue = 'bottom start';
    }
    frame(options) {
        const { origin, size } = this.parent().frame(options);
        return new Frame(origin.x - (options.other.size.width - size.width) / 2 + options.offsets.left, origin.y, size.width, size.height);
    }
    flex() {
        return {
            direction: 'column-reverse',
            alignment: 'flex-start',
        };
    }
    parent() {
        return PopoverPlacements.BOTTOM;
    }
    reverse() {
        return PopoverPlacements.TOP_START;
    }
    family() {
        return this.parent().family();
    }
    fits(frame, other) {
        return this.parent().fits(frame, other);
    }
};
PopoverPlacements.BOTTOM_END = new class {
    constructor() {
        this.rawValue = 'bottom end';
    }
    frame(options) {
        const { origin, size } = this.parent().frame(options);
        return new Frame(origin.x + (options.other.size.width - size.width) / 2 - options.offsets.right, origin.y, size.width, size.height);
    }
    flex() {
        return {
            direction: 'column-reverse',
            alignment: 'flex-end',
        };
    }
    parent() {
        return PopoverPlacements.BOTTOM;
    }
    reverse() {
        return PopoverPlacements.TOP_END;
    }
    family() {
        return this.parent().family();
    }
    fits(frame, other) {
        return this.parent().fits(frame, other);
    }
};
const fitsStart = (frame, other) => {
    return I18nLayoutService.select(fitsLeft, fitsRight)(frame, other);
};
const fitsEnd = (frame, other) => {
    return I18nLayoutService.select(fitsRight, fitsLeft)(frame, other);
};
const fitsLeft = (frame, other) => {
    return frame.origin.x >= other.origin.x;
};
const fitsRight = (frame, other) => {
    return frame.origin.x + frame.size.width <= other.size.width;
};
const fitsTop = (frame, other) => {
    return frame.origin.y >= other.origin.y;
};
const fitsBottom = (frame, other) => {
    return frame.origin.y + frame.size.height <= other.size.height;
};
//# sourceMappingURL=type.js.map