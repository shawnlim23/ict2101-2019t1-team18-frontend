/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from 'react';
import { Animated, Easing, PanResponder, StyleSheet, View, } from 'react-native';
import { Interaction, styled, } from '../../theme';
import { Text, } from '../text/text.component';
import { CheckMark } from '../support/components';
import { I18nLayoutService } from '../support/services';
/**
 * Styled `Toggle` component.
 *
 * @extends React.Component
 *
 * @property {boolean} checked - Determines whether component is checked.
 * Default is `false`.
 *
 * @property {boolean} disabled - Determines whether component is disabled.
 * Default is `false`.
 *
 * @property {string} status - Determines the status of the component.
 * Can be `primary`, `success`, `info`, `warning`, `danger`, `basic` or `control`.
 * Default is `basic`.
 *
 * @property {string} size - Determines the size of the component.
 * Can be `giant`, `large`, `medium`, `small`, or `tiny`.
 * Default is `medium`.
 *
 * @property {string} text - Determines text of the component.
 *
 * @property {StyleProp<TextStyle>} textStyle - Customizes text style.
 *
 * @property {(checked: boolean) => void} onChange - Fires when selection state is changed.
 *
 * @property TouchableOpacityProps
 *
 * @property StyledComponentProps
 *
 * @overview-example Simple Usage
 *
 * ```
 * import React from 'react';
 * import { Toggle } from '../..';
 *
 * export class ToggleShowcase extends React.Component {
 *
 *   state = {
 *     checked: false,
 *   };
 *
 *   onChange = (checked) => {
 *     this.setState({ checked });
 *   };
 *
 *   render() {
 *     return (
 *       <Toggle
 *         checked={this.state.checked}
 *         onChange={this.onChange}
 *       />
 *     );
 *   }
 * }
 * ```
 *
 * @overview-example With Text
 *
 * ```
 * import React from 'react';
 * import { Toggle } from '../..';
 *
 * export class ToggleShowcase extends React.Component {
 *
 *   state = {
 *     checked: false,
 *   };
 *
 *   onChange = (checked) => {
 *     this.setState({ checked });
 *   };
 *
 *   render() {
 *     return (
 *       <Toggle
 *         text='Place your text'
 *         checked={this.state.checked}
 *         onChange={this.onChange}
 *       />
 *     )
 *   }
 * }
 * ```
 *
 * @overview-example Eva Styling
 *
 * ```
 * import React from 'react';
 * import { Toggle } from '../..';
 *
 * export class ToggleShowcase extends React.Component {
 *
 *   state = {
 *     checked: false,
 *   };
 *
 *   onChange = (checked) => {
 *     this.setState({ checked });
 *   };
 *
 *   render() {
 *     return (
 *       <Toggle
 *         size='small'
 *         status='info'
 *         checked={this.state.checked}
 *         onChange={this.onChange}
 *       />
 *     );
 *   }
 * }
 * ```
 *
 * @example Inline Styling
 *
 * ```
 * import React from 'react';
 * import { StyleSheet } from 'react-native';
 * import { Toggle } from '../..';
 *
 * export class ToggleShowcase extends React.Component {
 *
 *   state = {
 *     checked: false,
 *   };
 *
 *   onChange = (checked) => {
 *     this.setState({ checked });
 *   };
 *
 *   render() {
 *     return (
 *       <Toggle
 *         textStyle={styles.toggleText}
 *         text='Place your Text'
 *         checked={this.state.checked}
 *         onChange={this.onChange}
 *       />
 *     );
 *   }
 * }
 *
 * const styles = StyleSheet.create({
 *   toggleText: { color: 'black' },
 * });
 * ```
 */
export class ToggleComponent extends React.Component {
    constructor(props) {
        super(props);
        this.onStartShouldSetPanResponder = () => {
            return true;
        };
        this.onStartShouldSetPanResponderCapture = () => {
            return true;
        };
        this.onMoveShouldSetPanResponder = () => {
            return true;
        };
        this.onMoveShouldSetPanResponderCapture = () => {
            return true;
        };
        this.onPanResponderTerminationRequest = () => {
            return false;
        };
        this.onPanResponderGrant = () => {
            const { checked, disabled, themedStyle } = this.props;
            if (disabled) {
                return;
            }
            this.onPressIn();
            if (this.thumbTranslateAnimationActive) {
                this.thumbTranslateAnimationActive = false;
                this.stopAnimations();
                return;
            }
            this.animateThumbWidth(themedStyle.thumbWidth * 1.2);
            this.animateEllipseScale(checked ? 1 : 0.01);
        };
        this.onPanResponderMove = () => {
            return true;
        };
        this.onPanResponderRelease = (e, gestureState) => {
            const { checked, disabled, themedStyle } = this.props;
            if (!disabled) {
                if ((!checked && gestureState.dx > -5) || (checked && gestureState.dx < 5)) {
                    this.toggle(this.onPress);
                }
                else {
                    this.animateEllipseScale(checked ? 0.01 : 1);
                }
            }
            this.animateThumbWidth(themedStyle.thumbWidth);
            this.onPressOut();
        };
        this.onPressIn = () => {
            this.props.dispatch([Interaction.ACTIVE]);
        };
        this.onPressOut = () => {
            this.props.dispatch([]);
        };
        this.onPress = () => {
            if (this.props.onChange) {
                this.props.onChange(!this.props.checked);
            }
        };
        this.getComponentStyle = (source) => {
            const { style, checked, disabled } = this.props;
            const { outlineWidth, outlineHeight, outlineBorderRadius, outlineBackgroundColor, thumbWidth, thumbHeight, thumbBorderRadius, thumbBackgroundColor, textMarginHorizontal, textFontSize, textFontWeight, textLineHeight, textFontFamily, textColor, iconWidth, iconHeight, iconTintColor, offsetValue, backgroundColor, borderColor } = source, containerParameters = __rest(source, ["outlineWidth", "outlineHeight", "outlineBorderRadius", "outlineBackgroundColor", "thumbWidth", "thumbHeight", "thumbBorderRadius", "thumbBackgroundColor", "textMarginHorizontal", "textFontSize", "textFontWeight", "textLineHeight", "textFontFamily", "textColor", "iconWidth", "iconHeight", "iconTintColor", "offsetValue", "backgroundColor", "borderColor"]);
            const interpolatedBackgroundColor = this.getInterpolatedColor(backgroundColor, borderColor);
            const thumbScale = this.animateThumbScale(offsetValue);
            return {
                toggleContainer: {},
                ellipseContainer: Object.assign({ borderColor: borderColor, backgroundColor: interpolatedBackgroundColor }, containerParameters),
                highlight: {
                    width: outlineWidth,
                    height: outlineHeight,
                    borderRadius: outlineBorderRadius,
                    backgroundColor: outlineBackgroundColor,
                },
                ellipse: {
                    width: containerParameters.width - (containerParameters.borderWidth * 2),
                    height: containerParameters.height - (containerParameters.borderWidth * 2),
                    borderRadius: (source.height - (source.borderWidth * 2)) / 2,
                    backgroundColor: interpolatedBackgroundColor,
                    transform: [{ scale: checked ? thumbScale : this.ellipseScaleAnimation }],
                },
                thumb: {
                    alignSelf: checked ? 'flex-end' : 'flex-start',
                    width: this.thumbWidthAnimation,
                    height: thumbHeight,
                    borderRadius: thumbBorderRadius,
                    backgroundColor: thumbBackgroundColor,
                    elevation: disabled ? 0 : 5,
                    transform: [{ translateX: this.thumbTranslateAnimation }],
                },
                text: {
                    marginHorizontal: textMarginHorizontal,
                    fontSize: textFontSize,
                    fontWeight: textFontWeight,
                    lineHeight: textLineHeight,
                    fontFamily: textFontFamily,
                    color: textColor,
                },
                icon: {
                    width: source.iconWidth,
                    height: source.iconHeight,
                    backgroundColor: iconTintColor,
                },
            };
        };
        this.animateThumbTranslate = (value, callback = () => null) => {
            this.thumbTranslateAnimationActive = true;
            Animated.timing(this.thumbTranslateAnimation, {
                toValue: I18nLayoutService.select(value, -value),
                duration: 150,
                easing: Easing.linear,
            }).start(() => {
                this.thumbTranslateAnimationActive = false;
                callback();
            });
        };
        this.animateThumbWidth = (value, callback = () => null) => {
            Animated.timing(this.thumbWidthAnimation, {
                toValue: value,
                duration: 150,
                easing: Easing.linear,
            }).start(callback);
        };
        this.animateEllipseScale = (value, callback = () => null) => {
            Animated.timing(this.ellipseScaleAnimation, {
                toValue: value,
                duration: 200,
                easing: Easing.linear,
            }).start(callback);
        };
        this.animateThumbScale = (value) => {
            return this.thumbTranslateAnimation.interpolate({
                inputRange: [-value, 0],
                outputRange: [1, 0.01],
            });
        };
        this.stopAnimations = () => {
            const value = this.props.checked ? 0.01 : 1;
            this.thumbTranslateAnimation.stopAnimation();
            this.ellipseScaleAnimation.stopAnimation();
            this.thumbWidthAnimation.stopAnimation();
            this.ellipseScaleAnimation.setValue(value);
        };
        this.toggle = (callback = (nextValue) => null) => {
            const { checked, themedStyle } = this.props;
            const value = checked ? -themedStyle.offsetValue : themedStyle.offsetValue;
            this.animateThumbTranslate(value, () => {
                this.thumbTranslateAnimation.setValue(0);
                callback(!checked);
            });
            this.animateThumbWidth(this.props.themedStyle.thumbWidth);
        };
        this.getInterpolatedColor = (startColor, endColor) => {
            const { checked, themedStyle } = this.props;
            return this.thumbTranslateAnimation.interpolate({
                inputRange: checked ? [-themedStyle.offsetValue, 0] : [0, themedStyle.offsetValue],
                outputRange: [startColor, endColor],
            });
        };
        this.renderTextElement = (style) => {
            return (<Text style={[style, this.props.textStyle]}>
        {this.props.text}
      </Text>);
        };
        this.renderComponentChildren = (style) => {
            return [
                this.props.text && this.renderTextElement(style.text),
            ];
        };
        const { checked, themedStyle } = props;
        this.thumbWidthAnimation = new Animated.Value(themedStyle.thumbWidth);
        this.thumbTranslateAnimation = new Animated.Value(0);
        this.ellipseScaleAnimation = new Animated.Value(checked ? 0.01 : 1.0);
        this.thumbTranslateAnimationActive = false;
        this.panResponder = PanResponder.create(this);
    }
    render() {
        const _a = this.props, { themedStyle, style, disabled, checked } = _a, restProps = __rest(_a, ["themedStyle", "style", "disabled", "checked"]);
        const componentStyle = this.getComponentStyle(themedStyle);
        const [textElement] = this.renderComponentChildren(componentStyle);
        return (<View {...restProps} {...this.panResponder.panHandlers} style={[styles.container, style]}>
        <View style={[componentStyle.toggleContainer, styles.toggleContainer]}>
          <View style={[componentStyle.highlight, styles.highlight]}/>
          <Animated.View style={[componentStyle.ellipseContainer, styles.ellipseContainer]}>
            <Animated.View style={[componentStyle.ellipse, styles.ellipse]}/>
            <Animated.View style={[componentStyle.thumb, styles.thumb]}>
              <CheckMark style={componentStyle.icon} isAnimated={true}/>
            </Animated.View>
          </Animated.View>
        </View>
        {textElement}
      </View>);
    }
}
ToggleComponent.styledComponentName = 'Toggle';
const styles = StyleSheet.create({
    container: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
    },
    toggleContainer: {
        alignItems: 'center',
        justifyContent: 'center',
    },
    ellipseContainer: {
        justifyContent: 'center',
        alignSelf: 'center',
        overflow: 'hidden',
    },
    ellipse: {
        alignSelf: 'center',
        position: 'absolute',
    },
    highlight: {
        alignSelf: 'center',
        position: 'absolute',
    },
    thumb: {
        justifyContent: 'center',
        alignItems: 'center',
    },
});
export const Toggle = styled(ToggleComponent);
//# sourceMappingURL=toggle.component.js.map